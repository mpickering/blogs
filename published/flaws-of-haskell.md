# The Four Flaws of Haskell

_Summary: Last year I made a list of four flaws with Haskell. Most have improved significantly over the last year._

No language/compiler ecosystem is without its flaws. A while ago I made a list of the flaws I thought might harm people using [Haskell](https://www.haskell.org/) in an industrial setting. These are not flaws that impact beginners, or flaws that stop people from switching to Haskell, but those that might harm a big project. Naturally, everyone would come up with a different list, but here is mine. 

__Package Management:__ Installing a single consistent set of packages used across a large code base used to be difficult. Upgrading packages within that set was even worse. On Windows, anything that required a new [`network` package](https://hackage.haskell.org/package/network) was likely to end in tears. The [MinGHC project](https://github.com/fpco/minghc) solved the network issue. [Stackage](https://www.stackage.org/) solved the consistent set of packages, and [Stack](https://docs.haskellstack.org/en/stable/README/) made it even easier. I now consider Haskell package management a strength for large projects, not a risk.

__IDE:__ The lack of an IDE certainly harms Haskell. There are a number of possibilities, but whenever I've tried them they have come up lacking. The fact that every Haskell programmer has an entrenched editor choice doesn't make it an easier task to solve. Fortunately, with [Ghcid](https://github.com/ndmitchell/ghcid#readme) there is at least something near the minimum acceptable standard for everyone. At the same time various IDE projects have appeared, notably the [Haskell IDE Engine](https://github.com/haskell/haskell-ide-engine) and [Intero](https://github.com/commercialhaskell/intero). With Ghcid the lack of an IDE stops being a risk, and with the progress on other fronts I hope the Haskell IDE story continues to improve.

__Space leaks:__ As Haskell programs get bigger, the chance of hitting a space leak increases, becoming an inevitability. While I am a big fan of laziness, space leaks are the big downside. Realising space leaks were on my flaws list, I started investigating methods for detecting space leaks, coming up with a [simple detection method](http://neilmitchell.blogspot.co.uk/2015/09/detecting-space-leaks.html) that works well. I've continued applying this method to [other libraries](http://neilmitchell.blogspot.co.uk/2016/05/another-space-leak-quickcheck-edition.html) and [tools](http://neilmitchell.blogspot.co.uk/2016/07/more-space-leaks-alexhappy-edition.html). I'll be giving a talk on space leaks at [Haskell eXchange 2016](https://skillsmatter.com/conferences/7276-haskell-exchange-2016#program). With these techniques space leaks don't go away, but they can be detected with ease and solved relatively simply - no longer a risk to Haskell projects.

__Array/String libraries:__ When working with strings/arrays, the libraries that tend to get used are [`vector`](https://hackage.haskell.org/package/vector), [`bytestring`](https://hackage.haskell.org/package/bytestring), [`text`](https://hackage.haskell.org/package/text) and [`utf8-string`](https://hackage.haskell.org/package/utf8-string). While each are individually nice projects, they don't work seamlessly together. The `utf8-string` provides UTF8 semantics for `bytestring`, which provides pinned byte arrays. The `text` package provides UTF16 encoded unpinned `Char` arrays. The `vector` package provides mutable and immutable vectors which can be either pinned or unpinned. I think the ideal situation would be a type that was either pinned or unpinned based on size, where the string was just a UTF8 encoded array with a `newtype` wrapping. Fortunately the [`foundation` library](https://github.com/haskell-foundation/foundation/) provides exactly that. I'm not brave enough to claim a 0.0.1 package released yesterday has derisked Haskell projects, but things are travelling in the right direction.

It has certainly been possible to use Haskell for large projects for some time, but there were some risks. With the improvements over the last year the remaining risks have decreased markedly. In contrast, the risks of using an untyped or impure language remain significant, making Haskell a great choice for new projects.
